\documentclass[acmsmall]{acmart}

\setcopyright{rightsretained}
\copyrightyear{2021}
\acmYear{2021}
\acmConference[HATRA '21]{Human Aspects of Types and Reasoning Assistants}{October 2021}{Chicago, IL}

\newcommand{\squnder}[1]{\underline{#1}}
\newcommand{\infer}[2]{\frac{\textstyle#1}{\textstyle#2}}

\begin{document}

\title{Position Paper: Goals of the Luau Type System}

\author{Andy Friesen}
\author{Alan Jeffrey}
\author{Other People?}
\affiliation{
  \institution{Roblox}
  \city{San Mateo}
  \state{CA}
  \country{USA}
}

\begin{abstract}
  A position paper about goals of the Luau type system.
\end{abstract}

\maketitle

\section{Introduction}

The Roblox~\cite{Roblox} platform allows anyone to create shared,
immersive, 3D experiences.  At the time of writing, there are
approximately eight million experiences available on Roblox, created
by eight million developers.  Roblox creators are often young, for
example there are over 200 Roblox kids' coding camps in over 65 countries
listed at~\cite{AllEducators}.

The Luau programming language~\cite{Luau} is the scripting language
used by developers of Roblox experiences. Luau is derived from the Lua
programming language~\cite{Lua}, with additional capabilities,
including a type inference engine.

This paper will discuss some of the goals of the Luau type system,
focusing on where the goals are different from those of other type systems.

\section{Human Aspects}
\subsection{Heterogenous developer community}

Quoting a 2020 report \cite{RobloxDevelopers}:
\begin{itemize}
\item Adopt Me! now has over 10 billion plays and surpassed 1.6 million concurrent users in game earlier this year.
\item Piggy, launched in January 2020, has close to 5 billion visits in just over six months.
\item There are now 345,000 developers on the platform who are monetizing their games.
\end{itemize}
This demonstrates how heterogenous the Roblox developer community is:
developers of experiences with plays measured in billions are on the same
platform as children first learning to code. Moreover, \emph{both of
these groups are important}, as the professional development studios
bring high-quality experiences to the platform, and the beginning creators
contribute to the energetic creative community.

\subsection{Goal-driven learning}

All developers are goal-driven, but this is especially true for
learners. A learner will download Roblox Studio (the IDE) with an
experience in mind, often designing an obstacle course (an ``obby'')
to play in with their friends.

The user experience of developing a Roblox experience is primarily a
3D interactive one, seen in Fig.~\ref{fig:studio}(a). The user designs
and deploys 3D assets such as terrain, parts and joints, and provides
them with physics attributes such as mass and orientation. The user
can interact with the experience in Studio, and deploy it to a Roblox
server so anyone with the Roblox app can play it.

\begin{figure}
\includegraphics[width=0.48\textwidth]{studio-mow.png}
\includegraphics[width=0.48\textwidth]{studio-script-editor.png}
\caption{Roblox Studio's 3D environment editor (a), and script editor (b)}
\label{fig:studio}
\end{figure}

At some point during experience design, the user of Studio has a need
which can't be met by the physics engine alone. ``The stairs should
light up when a player walks on them'' or ``a firework is set off
every few seconds.'' At this point they will discover the script
editor, seen in Fig.~\ref{fig:studio}(b), and the Luau programming language.

This onboarding experience is different from many initial exposures to
programming, in that by the time the user first opens the script
editor, they have already built much of their creation, and have a
very specific concrete aim.  It suggests a Luau goal for helping the
majority of creators: \emph{support learning how to perform specific
tasks} (for example through autocomplete suggestions and
documentation).

\subsection{Type-driven development}

Professional development studios are also goal-directed (though the
goals may be more abstract, such as ``decrease user churn'' or
``improve frame rate'') but have needs that are less common in
learners:
\begin{itemize}

\item \emph{Code planning}:
  code spends much of its development time in an incomplete state,
  with holes that will be filled in later.

\item \emph{Code refactoring}:
  experiences evolve over time, and it easy for changes to
  break previously-held invariants.

\item \emph{Defect detection}:
  code has errors, and detecting these at runtime (for example by crash telemetry)
  can be expensive and recovery can be time-consuming.
  
\end{itemize}
Detecting defects ahead-of-time is a traditional goal of type systems,
resulting in an array of techniques for establishing safety results,
surveyed for example in~\cite{TAPL}. Supporting code planning and
refactoring are some of the goals of \emph{type-driven
development}~\cite{TDDIdris} under the slogan ``type, define,
refine''.

To help support the transition from novice to experienced developer,
types are introduced gradully, through API documentation and type discovery.
Type inference provides many of the benefits of type-driven development
even to creators who are not explicitly providing types.

\section{Types}
\subsection{Infallible types}

Goal: \emph{support type-driven tools in all programs}.

Programs spend much of their time under development in an incomplete state, even if the final arifact
is well-typed. Type-driven tools should support this, by providing type information for all programs.

An analogy is infallible parsers, which perform error recovery and provide an AST for all input texts.

Program analysis can still flag type errors, for example with red
squiggly underlining. Formalizing this, rather than a judgement
$\Gamma\vdash M:T$, for an input terms $M$, there is a judgement
$\Gamma \vdash M \Rightarrow M' : T$ where $M'$ is an output term
where some subterms are flagged $\squnder{M}$. For example the usual type rules for field access becomes:
\[
  \infer{
    \Gamma \vdash M \Rightarrow M' : T
  }{
    \Gamma \vdash M.\ell \Rightarrow M'.\ell : U
  }
  [
    T = \{ \overline{\ell:U} \} \mbox{ and } (\ell:U) \in (\overline{\ell:U})
  ]
\]
but there is also a rule for unsuccesful field access:  
\[
  \infer{
    \Gamma \vdash M \Rightarrow M' : T
  }{
    \Gamma \vdash M.\ell \Rightarrow \squnder{M'.\ell} : U
  }
  [
    T = \{ \overline{\ell:U} \} \mbox{ implies } \ell \not\in \overline{\ell}
  ]
\]
In this type rule, $U$ is unconstrained.

Some issues raised by infallible types:
\begin{itemize}
\item Which heuristics should be used to provide types for flagged programs? For example, could one
  use minimal edit distance to correct for spelling mistakes in field names?
\item How can we avoid cascading type errors, where a developer is
  faced with type errors that are artifacts of the heuristics rather
  than genuine errors?
\item How can the goals of an infallible type system be formalized?
\end{itemize}

\subsection{Strict types}

Goal: no false negatives

- Appropriate for experienced developers?

- Variants of ``usual techniques'' apply, e.g. progress becomes ``if you get stuck, there must be red squigglies''

- Related to blame analysis?

\subsection{Nonstrict types}

Goal: no false positives

- Appropriate for the majority of developers?

- Usual techniques do not apply, e.g. correctness becomes ``code with red squigglies does not return a result''

- Related to success types?

- Problems with mutation and avoiding whole-program analysis.

\subsection{Mixing types}

Goal: support mixed strict/nonstrict development

- Strictness is per-script, so programs are mixed

- Can the correctness criteria be combined?

- Can success types be combined with regular types?

- Same types, different red squigglies?

- Related: incorrectness logic vs correcness logic?

\section{Future work}

Draw the damn owl

- Mixing types

- Other interactions between types and IDEs, e.g. typed holes.

- Formalizations of all of this?

\bibliographystyle{ACM-Reference-Format} \bibliography{bibliography}

\end{document}
